<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Parametric Ribbon Sculptor</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #f8f4e8;
      font-family: sans-serif;
    }

    #pane {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 100;
    }

    #export {
      position: absolute;
      bottom: 12px;
      left: 12px;
      z-index: 100;
      display: flex;
      gap: 8px;
    }

    button {
      padding: 8px 12px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background: #555;
    }

    canvas {
      display: block;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168/examples/js/exporters/GLTFExporter.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweakpane@4.0.3/dist/tweakpane.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tweakpane/plugin-essentials@0.2.0/dist/tweakpane-plugin-essentials.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/simplex-noise.min.js"></script>
</head>

<body>
  <div id="pane"></div>
  <div id="export"></div>

  <script>
    // Robust init after DOM + scripts load
    window.addEventListener('load', function() {
      if (typeof THREE === 'undefined' || typeof Tweakpane === 'undefined') {
        console.error('Libraries failed to load. Check your connection and refresh.');
        return;
      }
      init();
    });

    function init() {
      const {
        Pane
      } = Tweakpane;
      const {
        GLTFExporter
      } = THREE;
      const {
        jsPDF
      } = window.jspdf.jsPDF;
      // ---------- Scene ----------
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8f4e8);
      const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);
      camera.position.set(5, 4, 7);
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        preserveDrawingBuffer: true
      });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(devicePixelRatio);
      document.body.appendChild(renderer.domElement);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(5, 10, 7);
      scene.add(dir);
      // ---------- Mesh holders ----------
      let ribbon, base;
      // ---------- Noise ----------
      const simplex = new SimplexNoise();
      // ---------- Core geometry ----------
      function buildRibbon(p) {
        const {
          turns,
          height,
          width,
          thickness,
          gridX,
          gridY,
          phase,
          superTwist,
          waveAmp,
          waveFreq,
          bulge,
          taper,
          noiseAmt,
          tilt,
          wireframe
        } = p;
        const verts = [],
          indices = [];
        const du = 1 / (gridY - 1),
          dv = 1 / (gridX - 1);
        for (let j = 0; j < gridY; j++) {
          const u = j * du; // 0..1 along length
          const t = u * Math.PI * 2; // base angle
          // ---- envelope (bulge + taper) ----
          const mid = 0.5;
          const bulgeFactor = Math.exp(-Math.pow((u - mid) * 6, 2) * bulge);
          const taperFactor = 1 - u * taper;
          const env = bulgeFactor * taperFactor;
          // ---- wave ----
          const wave = waveAmp * Math.sin(t * waveFreq);
          for (let i = 0; i < gridX; i++) {
            let v = (i * dv) - 0.5; // -0.5..0.5 across width
            // ---- noise displacement ----
            const n = noiseAmt * simplex.noise3D(v * 5, u * 5, p.seed || 0);
            // ---- local width (affected by envelope & wave) ----
            const wx = (v * width + wave + n) * env;
            // ---- main twist + super-twist ----
            const twist = 2 * Math.PI * (u * turns + phase) + superTwist * Math.sin(t * 0.5);
            const x = wx * Math.cos(twist + Math.PI * v);
            const y = height * u;
            const z = wx * Math.sin(twist + Math.PI * v);
            // ---- thickness extrusion ----
            const extr = (v >= 0 ? thickness : -thickness);
            verts.push(x, y, z + extr);
          }
        }
        // indices (same as before)
        for (let j = 0; j < gridY - 1; j++) {
          for (let i = 0; i < gridX - 1; i++) {
            const a = j * gridX + i,
              b = a + 1,
              c = a + gridX,
              d = c + 1;
            indices.push(a, b, c, b, d, c); // front
            indices.push(c, b, a, c, d, b); // back
          }
        }
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
        geom.setIndex(indices);
        geom.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({
          color: 0x222222,
          metalness: 0.9,
          roughness: 0.2,
          wireframe
        });
        if (ribbon) scene.remove(ribbon);
        ribbon = new THREE.Mesh(geom, mat);
        ribbon.rotation.z = THREE.MathUtils.degToRad(tilt);
        scene.add(ribbon);
      }

      function buildBase(size) {
        if (base) scene.remove(base);
        const geom = new THREE.BoxGeometry(size, size * 0.4, size);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x111111,
          roughness: 0.9
        });
        base = new THREE.Mesh(geom, mat);
        base.position.y = -size * 0.2;
        scene.add(base);
      }
      // ---------- Parameters ----------
      const params = {
        turns: 2,
        height: 4,
        width: 1,
        thickness: 0.06,
        gridX: 40,
        gridY: 120,
        phase: 0,
        superTwist: 0,
        waveAmp: 0,
        waveFreq: 2,
        bulge: 0,
        taper: 0,
        noiseAmt: 0,
        seed: 0,
        tilt: 0,
        wireframe: true,
        baseSize: 1.2
      };
      // ---------- Tweakpane UI ----------
      const pane = new Pane({
        container: document.getElementById('pane')
      });
      const f1 = pane.addFolder({
        title: 'Core'
      });
      f1.addBinding(params, 'turns', {
        min: 0,
        max: 6,
        step: 0.1
      });
      f1.addBinding(params, 'height', {
        min: 1,
        max: 10,
        step: 0.1
      });
      f1.addBinding(params, 'width', {
        min: 0.2,
        max: 3,
        step: 0.05
      });
      f1.addBinding(params, 'thickness', {
        min: 0,
        max: 0.2,
        step: 0.005
      });
      f1.addBinding(params, 'gridX', {
        min: 10,
        max: 80,
        step: 1
      });
      f1.addBinding(params, 'gridY', {
        min: 30,
        max: 200,
        step: 1
      });
      f1.addBinding(params, 'phase', {
        min: 0,
        max: 1,
        step: 0.01
      });
      f1.addBinding(params, 'tilt', {
        min: -90,
        max: 90,
        step: 1
      });
      const f2 = pane.addFolder({
        title: 'Shape Modulators'
      });
      f2.addBinding(params, 'superTwist', {
        min: -3,
        max: 3,
        step: 0.1
      });
      f2.addBinding(params, 'waveAmp', {
        min: 0,
        max: 2,
        step: 0.05
      });
      f2.addBinding(params, 'waveFreq', {
        min: 0,
        max: 10,
        step: 0.1
      });
      f2.addBinding(params, 'bulge', {
        min: 0,
        max: 1,
        step: 0.01
      });
      f2.addBinding(params, 'taper', {
        min: 0,
        max: 1,
        step: 0.01
      });
      f2.addBinding(params, 'noiseAmt', {
        min: 0,
        max: 0.5,
        step: 0.01
      });
      f2.addBinding(params, 'seed', {
        min: 0,
        max: 1000,
        step: 1
      });
      const f3 = pane.addFolder({
        title: 'Render'
      });
      f3.addBinding(params, 'wireframe');
      f3.addBinding(params, 'baseSize', {
        min: 0.5,
        max: 2,
        step: 0.05
      });
      pane.on('change', () => update());
      // ---------- Export UI ----------
      const exp = document.getElementById('export');
      const btnGLB = document.createElement('button');
      btnGLB.textContent = '⬇ GLB';
      btnGLB.onclick = exportGLB;
      exp.appendChild(btnGLB);
      const btnPDF = document.createElement('button');
      btnPDF.textContent = '⬇ PDF (6 views)';
      btnPDF.onclick = exportPDF;
      exp.appendChild(btnPDF);
      // ---------- Update ----------
      function update() {
        buildRibbon(params);
        buildBase(params.baseSize);
      }
      update();
      // ---------- GLB Export (callback-based for compatibility) ----------
      function exportGLB() {
        const exporter = new GLTFExporter();
        exporter.parse(ribbon, function(glb) {
          const blob = new Blob([glb], {
            type: 'application/octet-stream'
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'sculpture.glb';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, {
          binary: true
        });
      }
      // ---------- PDF Export (6 orthographic views) ----------
      function exportPDF() {
        const pdf = new jsPDF({
          orientation: 'portrait',
          unit: 'mm',
          format: 'a4'
        });
        const views = [{
            azim: 0,
            elev: 0,
            label: 'Front'
          },
          {
            azim: 180,
            elev: 0,
            label: 'Back'
          },
          {
            azim: 90,
            elev: 0,
            label: 'Left'
          },
          {
            azim: -90,
            elev: 0,
            label: 'Right'
          },
          {
            azim: 0,
            elev: 90,
            label: 'Top'
          },
          {
            azim: 0,
            elev: -90,
            label: 'Bottom'
          }
        ];
        const size = 80; // mm per view
        const margin = 15;
        const cols = 2,
          rows = 3;
        let renderIndex = 0;

        function renderNext() {
          if (renderIndex >= views.length) {
            pdf.save('sculpture_views.pdf');
            return;
          }
          const v = views[renderIndex];
          const col = renderIndex % cols,
            row = Math.floor(renderIndex / cols);
          const x = margin + col * (size + margin);
          const y = margin + row * (size + margin);
          // temporary ortho camera
          const ortho = new THREE.OrthographicCamera(-3, 3, 3, -3, 0.1, 100);
          ortho.position.setFromSphericalCoords(8, THREE.MathUtils.degToRad(90 - v.elev), THREE.MathUtils.degToRad(v.azim));
          ortho.lookAt(0, 1.5, 0);
          ortho.updateProjectionMatrix();
          renderer.render(scene, ortho);
          const data = renderer.domElement.toDataURL('image/png', 1.0); // High quality
          pdf.addImage(data, 'PNG', x, y, size, size);
          pdf.setFontSize(10);
          pdf.text(v.label, x + size / 2, y + size + 8, {
            align: 'center'
          });
          renderIndex++;
          setTimeout(renderNext, 50); // Small delay to avoid render queue issues
        }
        renderNext();
      }
      // ---------- Animation ----------
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
      // ---------- Resize ----------
      window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    }
  </script>
</body>

</html>
