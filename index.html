<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Parametric Ribbon Sculptor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { margin:0; overflow:hidden; background:#f8f4e8; font-family:sans-serif; }
    #pane   { position:absolute; top:10px; left:10px; z-index:100; background:rgba(255,255,255,0.95); padding:10px; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,0.1); }
    #export { position:absolute; bottom:10px; left:10px; z-index:100; display:flex; gap:8px; }
    button { padding:8px 16px; background:#222; color:white; border:none; border-radius:4px; cursor:pointer; font-size:14px; }
    button:hover { background:#444; }
    canvas { display:block; }
    #loading { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#666; font-size:18px; }
  </style>
</head>
<body>

<div id="loading">Loading 3D engine...</div>
<div id="pane"></div>
<div id="export"></div>

<!-- THREE.JS CORE -->
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/exporters/GLTFExporter.js"></script>

<!-- TWEAKPANE (UI) -->
<script src="https://cdn.jsdelivr.net/npm/tweakpane@4.0.3/dist/tweakpane.min.js"></script>

<!-- JSPDF (PDF Export) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<!-- SIMPLEX NOISE (Organic Shapes) -->
<script src="https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/simplex-noise.min.js"></script>

<script>
  // Wait for all libraries
  const libs = ['THREE', 'Tweakpane', 'jsPDF', 'SimplexNoise'];
  function check() {
    if (libs.every(l => window[l])) {
      document.getElementById('loading').remove();
      init();
    } else {
      setTimeout(check, 100);
    }
  }
  check();

  function init() {
    const {Pane} = Tweakpane;
    const {jsPDF} = window.jspdf;

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8f4e8);
    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(5, 4, 7);
    const renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 10, 7);
    scene.add(light);

    let ribbon, base;
    const noise = new SimplexNoise();

    // Build ribbon
    function build(p) {
      const {turns, height, width, thick, gx, gy, phase, stwist, waveA, waveF, bulge, taper, noiseA, tilt, wire, seed} = p;
      const verts = [], idx = [];
      const du = 1/(gy-1), dv = 1/(gx-1);

      for (let j = 0; j < gy; j++) {
        const u = j * du;
        const env = Math.exp(-Math.pow((u-0.5)*6,2)*bulge) * (1 - u*taper);
        const wave = waveA * Math.sin(u * Math.PI * 2 * waveF);

        for (let i = 0; i < gx; i++) {
          const v = (i*dv) - 0.5;
          const n = noiseA * noise.noise3D(v*5, u*5, seed);
          const w = (v*width + wave + n) * env;
          const twist = 2*Math.PI*(u*turns + phase) + stwist*Math.sin(u*Math.PI);
          const x = w * Math.cos(twist + Math.PI*v);
          const y = height * u;
          const z = w * Math.sin(twist + Math.PI*v);
          verts.push(x, y, z + (v>=0 ? thick : -thick));
        }
      }

      for (let j = 0; j < gy-1; j++) {
        for (let i = 0; i < gx-1; i++) {
          const a = j*gx+i, b=a+1, c=a+gx, d=c+1;
          idx.push(a,b,c, b,d,c, c,b,a, c,d,b);
        }
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
      geom.setIndex(idx);
      geom.computeVertexNormals();
      const mat = new THREE.MeshStandardMaterial({color:0x222222, metalness:0.9, roughness:0.2, wireframe:wire});
      if (ribbon) scene.remove(ribbon);
      ribbon = new THREE.Mesh(geom, mat);
      ribbon.rotation.z = THREE.MathUtils.degToRad(tilt);
      scene.add(ribbon);
   
